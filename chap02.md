2. Detailed Design

2.1 High-Level Architecture

We take Ethereum blockchain as an example to briefly discuss the overall process of an
on-demand data query initiated by a user contract. It looks similar to the request & response pattern, however, it is an asynchronous process from user contract’s point of view:

①: User contract makes a data query request through a message call to DOS on-chain system (a bunch of smart contracts open sourced and published with well documentation provided to developers), specifically the DOS Proxy Contract;

②: DOS Proxy Contract triggers an event along with query parameters;

③: DOS clients (off-chain part of DOS Network running by users), which keep monitoring the blockchain for the defined event, are notified. Ideally there would be thousands of DOS instances running, out of which a registered group will be randomly selected, by means of the distributed randomness engine built with verifiable random function (VRF).

④ & ⑤: Members in the selected group do the due diligence, calling a web api, performing a computation, or executing a configured script concurrently;

⑥: They will reach "in-group" consensus by the t-out-of-n threshold signature algorithm and report back the agreed result to DOS on-chain system, as long as more than t members in the randomly selected group are honest. The selected group members’ identity and QoS (responsiveness/correctness, etc.) performance will be recorded on-chain, for monitoring and data analysis purposes.

⑦: DOS Proxy Contract notifies the user contract that the result is ready, by calling a callback function provided by user contract.

** The overall workflow of verifiable computation oracle looks similar and also make use of the distributed randomness engine, but with several differences for step 4~6. We’ll discuss the details in later sections.


2.2 On-Chain Detailed Design

2.2.1 Proxy System


The proxy system provides standard on-chain interfaces to user contracts and will
asynchronously callback to user contracts once the response is ready. The interface
provided to user contracts is universal and simple as demonstrated below:


- Making a query request to DOS Proxy Contract;

- Consuming the result backfilled from `__callback__` function to finish some
post-processing work.

```
code
code
```

Alpha version of DOS on-chain contracts have been open-sourced on Github already
and will be keeping updated.


2.2.2 On-chain Governance Systems
Monitoring system


Monitoring system is proposed to keep on-chain records of the off-chain DOS
instances’ QoS (Quality-of-Service) metrics and network stats, including:
● Random number generated by latest round’s selected off-chain group, which
could serve as a new kind of on-chain random source;
● Group size, number of registered groups, number of times each registered
group has been selected, uptime and decomposition time to get rid of
adaptive adversaries, etc.;
● Payment, weight percentage, and callback delay stats of processed and
unhandled query requests;

● Quality score of registered off-chain DOS instances including correctness and
responsiveness of their reported results - instances with extremely bad quality
score will be excluded from off-chain consensus protocol and payment
process;
● More...

Based on these rich on-chain metrics a monitoring Dapp could be built, showcasing
the live status of DOS Network.


Registration system


For DOS off-chain instances to join the network, they need to stake and lock some
DOS tokens as security deposit, and to register their deposit address as well as
payment address in the registration contract. They will be registered within at least
one threshold group $Gi$ as groups may overlap with each other. The registration
process of threshold groups are described in the off-chain architecture section
below.


The security deposit makes the system resistant to sybil attacks and enhances
network security. It also serves as a kind of commitment that the node operator
would contribute bandwidth and computation power to strengthen DOS Network, and
they will be compensated for “mining” rewards as well as earning processing fees.
The lockup period helps stabilize the network to get rid of too frequent registration
and deregistration flips. Any instance with out-of-bound offtime would also be
penalized by forfeiting part of its deposit. Groups with no responses up to certain
limit would be removed from registration system.


Payment system
The payment of a query request goes to the selected threshold group that handles it,
and is distributed among honest members. Payments will be stored in the payment
contract first, as the transfer to node runners doesn’t necessarily happen in real time
- a withdrawal pattern is preferable and node operators are able to check and
withdraw their earnings through a frontend UI or interacting with payment contract
directly.

DOS token is used in the form of natively supported payment token, as well as the
staking token. However, for blockchains with widely-accepted stablecoins (e.g.
Ethereum), the stablecoin would be a preferable payment token since node runners
won’t be risking for the volatility of crypto prices; the pricing model for the fees will
also be easier to make. We’ll support DOS as payment token first, in the long run,
node runners and token holders will have governance rights to vote for which
stablecoins (DAI/USDC/TUSD/etc.) to be accepted as extra payment tokens.

Different payment schemes will also be supported: pay-per-use will be widely
adopted and suitable for personal developers and light-use Dapps, while discounted
subscription model will be more favorable to heavily dependent applications such as
stablecoins and other decentralized open finance platforms.

The on-chain system will take modular design pattern into mind that all on-chain
contracts will be upgradable. Since it’s an open and distributed network environment
with different parties have different economic appeals, there’s no simple perfect
model to rule them all. More governance experiments and economic models will be
researched and explored in future.
